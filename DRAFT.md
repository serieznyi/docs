# утилита p0f

P0f — это инструмент, который использует массив сложных, исключительно пассивных механизмов 
снятия отпечатков трафика для идентификации игроков стоящих за любым случайным TCP/IP 
соединением (иногда достаточно единичного нормального SYN) без какого бы то ни было вмешательства.

# микросервисы

 - версионирование только публичной части API. 
 - для внутренних изменений использовать commit hash
 - объединяем частоменяющиеся микросервисы в мета репозиторий. он же и хранит информацию о deploy. это позволит быстрее выкатывать частоменяющуюся группу.  

# Любимый софт
 - https://snapcraft.io/redis-desktop-manager Менеджер REDIS
 - https://sdkman.io SDK Man
 - https://github.com/astrada/google-drive-ocamlfuse

---

# ТОП ошибок в инфраструктуре, мешающих высоким нагрузкам / Андрей Половов (Флант)

## Проблемы с базами / Транзакции

Если обернуть N запросов к БД в транзакцию, то мы получим только 2 дисковых операций (Disk IO) вместо N.
Это особенно ощутимо на больших объемах данных. Например при парсинге и экспорте данных в БД.

По умолчанию в mysql включен autocommit.
В чистом php каждый запрос к БД будет обернут отдельной транзакцией.
В итоге на каждый запрос к БД мы получаем 3 дисковых операций.
Лучше оборачивать запросы к БД в транзакции собственноручно. 

## Проблемы с базами / Индексы

Не забывайте про индексы

## Проблемы с базами / Жадные запросы

Используйте `SELECT *` только когда это требуется

## Проблемы с кодом / HTTP-api

При обращении к стороннему API по HTTP из вашего приложения:
 - кешируйте ответ, что бы не делать лишние запросы 
 - ставьте timeout 
 - делайте запрос в фоне и сохраняйте его результат в хранилище
 
## Проблемы с кодом / cron
  - устанавливайте timeout на выполнение cron команды
  - используйте lock что бы одна и та же команда не запускалась в виде нескольких экземпляров
  
## Архитектурные проблемы / PHP-сессии
 
 PHP хранит сессии по умолчанию на диске.
 При большой нагрузке могут закончиться inodes.
 Лучше держать сессии в redis или memcached
 
## Архитектурные проблемы / HTTP-кеш
 Некоторые запросы стоит закешировать на уровне веб сервера
 
 
## Сетевые проблемы / persistent connect
 
 Для того, что бы PostgreSQL не приходиось на каждый WEB запрос создавать новое
 соединение с БД вы можете воспользоваться прокси PGBouncer
 
## Сетевые проблемы / TIME_WAIT-сокеты
 
 При борьбе с TIME_WAIT сокетами иногда используют след. настройки ядра
 
 net.ipv4tcp_tw_reuse = 1 # данная настройка вам не навредит
 net.ipv4tcp_tw_recycle = 1 # а вот эта настройка может привести к тому, что у малого процента пользователей не будет открываться  ваш сайт. Лучше ее не использовать.
 
 Лучше свести к минимум короткие TCP соедиения и вместо них используйте долгие соединения.
 
## Человеческий фактор / Базовые настройки

Не используйте стандартные настройки. Изучите как настроить новый софт
:google - %software% perfomance tuninig


 
